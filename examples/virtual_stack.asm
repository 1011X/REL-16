# a stack that grows to the right
# rel16 already has stack operations (`pop` and `push`),
# but I want to implement it manually as an exercise and to
# see if it's possible.

xori r0 255; stack pointer in r0 pointing to 0x00FF

# pushing a value (in this case, 3) to the stack
xori r1 3

inc r0; increment pointer value, stack base should always be 0
xchg r1 r0; exchange value of r1 for value at r0
; r1 is now 0, and [r0] is 1

# more code...

# popping value into r2
; we assume r2 is 0
xchg r2 r0; r2 = 1, [r0] = 0 (base)
dec r0


# ideally, every program should zero off any memory being used
# after it has finished. Currently this is tricky, but I'm
# curious to try and implement an instruction that reverses the
# machine until it reaches a `halt` instruction, which guarantees
# that memory is zero'd off (this, though, has the slight
# disadvantage that the whole program would have to be run in
# reverse).

# Uncommenting the following should zero out the memory used.
# This should be generated by a compiler to ensure it's done
# correctly.

; currently, r2 = 3, r0 = 255
;imm r2 3
;imm r0 255
hlt
